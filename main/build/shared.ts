import * as fs from 'fs';
import ccxt from '../../../js/ccxt.js';
import { tsPaths, ccxtDir } from './filepaths.js';
import path from 'path';

const generatedHeader = `// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

`;

/*
    Gets the methods that will be created in Swift and Android
*/
function getMethodNames(): string[] {
    const exchange = new ccxt.Exchange();
    return [
        ...Object.keys(exchange.has),
        'describe',
        'loadMarkets'
    ];
}

function getTypescriptHeaders(): [string, {[key: string]: [string, string | null]}, string][] {
    // Initialize empty array for results
    const results: [string, {[key: string]: [string, string | null]}, string][] = [];
    
    // Get the allowed method names
    const allowedMethods = new Set(getMethodNames());
    
    // Read the typescript file content
    const src = fs.readFileSync(tsPaths['exchange'], "utf8");
    
    // Match method declarations
    const methodRegex = /async\s+(\w+)\s*\(([\s\S]*?)\)\s*(?::\s*Promise\s*<\s*([\w\[\]]+)\s*>)?/g;
    
    let match;
    while ((match = methodRegex.exec(src)) !== null) {
        const methodName = match[1];
        
        // Skip if method is not in allowedMethods
        if (!allowedMethods.has(methodName)) {
            continue;
        }
        
        const params = match[2].trim();
        const returnType = match[3]?.trim() ?? "Any";
        
        // Initialize parameter dictionary for this method
        const paramDict: {[key: string]: [string, string | null]} = {};
        
        // Split parameters and process each one
        if (params) {
            const paramList = params.split(/,(?![^{]*})(?![^\[]*\])/).map(p => p.trim());
            
            for (const param of paramList) {
                // Match: name?: type = defaultValue
                const paramMatch = param.match(/^(\w+)(\?)?(?::\s*([^=]+))?\s*(?:=\s*(.+))?$/);
                if (paramMatch) {
                    const [, name, optional, type = 'any', defaultValue] = paramMatch;
                    const finalType = (type.trim() + (optional ? '?' : '')).replace(/\s+/g, '');
                    paramDict[name] = [finalType, defaultValue?.trim() || null];
                }
            }
        }
        
        results.push([methodName, paramDict, returnType]);
    }
    
    return results;
}

/**
 * Ensures the directory exists and writes/appends content to a file.
 * @param {string} filePath The path to the file.
 * @param {Array<string>} content The content of the file, line by line
 * @param {string | null} originalFilePath The path to the original file, if any.
 * @param {boolean} prepend Puts content at top of file if true
 * @param {boolean} noGeneratedHeader whether or not to prepend the 'this file is generated' header
 */
export function createGeneratedFile(
    filePath: string,
    content: string[],
    originalFilePath: string | null = null,
    replacements: {[key: string]: string} = {},
    noGeneratedHeader = false
) {

    const dirPath = path.dirname(filePath);
    if (!fs.existsSync(dirPath)) {  // Create the directory if it doesn't exist
        fs.mkdirSync(dirPath, { recursive: true });
    }
    const beginning = noGeneratedHeader ? '' : generatedHeader;
    fs.writeFileSync(filePath, beginning, 'utf8');

    if (originalFilePath) {
        let originalFileContent = fs.readFileSync(originalFilePath, 'utf8');
        for (const [key, value] of Object.entries(replacements)) {
            originalFileContent = originalFileContent.replace(new RegExp(key, 'g'), value);
        }
        fs.appendFileSync(filePath, originalFileContent, 'utf8');
    }
    let insert = '';
    if (content.length > 0) {
        insert = '\n' + content.join("\n") + '\n';
        for (const [key, value] of Object.entries(replacements)) {
            insert = insert.replace(new RegExp(key, 'g'), value);
        }
    }
    fs.appendFileSync(filePath, insert, 'utf8');
}

/**
 * @param {function} transpiler receives a string for a typescript method and creates a wrapper in another language
 * @param {string} originalFile file path for static non-transpiled content of the wrapper file
 * @param {string} newFile file path for the new wrapper file
 */
export function createWrapperFile (
    transpiler: (methodName: string, params: {[key: string]: [string, string | null]}, returnType: string) => string,
    originalFile: string,
    newFile: string,
    replacements: { [key: string]: string } = {},
    ws = false,
) {

    const methodDeclarations: string[] = [];
    const headers = getTypescriptHeaders ();
    for (const [methodName, params, returnType] of headers) {
        if ([
            'fetchCurrenciesWs',
            'fetchMarketsWs',
            'watchOHLCVForSymbols',
            'unWatchOHLCVForSymbols',

            // TODO: don't know how to make types encodable with params as type any
            'createOrders',
            'editOrders',
            'deleteOrders',
        ].includes(methodName) || 
        (!ws && (
            methodName.startsWith('watch') ||
            methodName.startsWith('unWatch') ||
            methodName.includes('Ws')
        ))) {
            continue;
        } else {
            methodDeclarations.push (
                transpiler (methodName, params, returnType)
            );
        }
    }

    // Exchange.swift and ccxtwrapper.go
    createGeneratedFile (newFile, methodDeclarations, originalFile, replacements);
}


export async function getLatestVersion(swift: boolean, pro: boolean) {
    let repo = swift ? "swift" : "android";
    if (pro) {
        repo += "-pro";
    }
    const url = `https://api.github.com/repos/ccxt-native/${repo}/releases/latest`;

    const response = await fetch(url, {
        headers: { "Accept": "application/vnd.github.v3+json" },
    });

    if (!response.ok) {
        throw new Error(`GitHub API error: ${response.status}`);
    }

    const data = await response.json();
    return data.tag_name;
}

export async function bumpVersion(swift: boolean, pro: boolean) {
    const version = await getLatestVersion(swift, pro);
    const [major, minor, patch] = version.replace(/^v/, "").split(".").map(Number);
    if (patch == 99) {
        return `v${major}.${minor + 1}.${patch}`;
    } else {
        return `v${major}.${minor}.${patch + 1}`;
    }    
}

export const customTypes = [   // Only those types that appear in swift headers
    'OrderRequest[]',
    'OrderRequest',
];

const exchangesJson = JSON.parse (fs.readFileSync(`${ccxtDir}/exchanges.json`, "utf8"));
export const allExchanges = exchangesJson.ids;
export const wsExchanges = exchangesJson.ws;