import * as fs from 'fs';
import path from 'path';
import ccxt from '../../../js/ccxt.js';
import { ccxtPaths, ccxtDir } from './filepaths.js';
import { MethodHeader, MethodTranspiler, Properties, Property, PropertyTranspiler, StringDict } from './types.js';

const generatedHeader = `// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

`;

const getPropRegexes = (filePath: string): { [key: string]: { type: string; defaultValue: string | undefined } } => {
    const fs = require('fs');
    const content = fs.readFileSync(filePath, 'utf-8');
    const regex = /^\s*([A-Za-z_][A-Za-z0-9_]*)\s*:\s*([^=;]+(?:<[^;]+>)*)\s*(?:=\s*({[\s\S]*?}|[^;]+))?\s*;/gms;
    const regexMatches: { [key: string]: { type: string; defaultValue: string | undefined } } = {};
    let match;
    while ((match = regex.exec(content)) !== null) {
        const [, name, type, defaultValue] = match;
        regexMatches[name] = { type: type.trim(), defaultValue: defaultValue?.trim() };
    }
    return regexMatches;
};

/**
 * @description Takes an instance of an object and reads all the properties on it, then uses a regex to get the type of the property, 
 * if there is no type, the default value of the property is used to determine the type
 * @param instance an instantiated instance of the object
 * @param filePath the path to the typescript file that contains the properties
 * @returns 
 */
export function getExchangeProperties (instance: any, filePath: string): Property[] {
    const properties: Properties = {};
    const getterOnlyProperties = new Set<string> ([
        // properties that should not be set
        'alias',
        'api',
        'features',
        'has',
        'headers',
        'hostname',
        'id',
        'last_request_body',
        'last_request_headers',
        'last_request_url',
        'markets',
        'requiredCredentials',
        'symbols',
        'timeframes',
        'urls',
        'version',
    ]);
    const setterOnlyProperties = new Set<string> ([
        // properties that should not be received, private properties, sensitive data
        'apiKey',
        'secret',
        'password',
        'twofa',
        'timeout',
        'verbose',
        'accounts',
        'privateKey',
        'walletAddress',
        'uid',
        'enableRateLimit',
    ]);
    // const asyncMethods = new Set<string>();
    
    const regexMatches = getPropRegexes(filePath);

    for (const [propertyName, propertyValue] of Object.entries(instance) as [string, any][]) {
        if (typeof propertyValue === 'function') {  // skip methods
            // TODO: create wrapper for methods here once all methods have types
            // if (propertyValue.constructor.name === "AsyncFunction") {
            //     asyncMethods.add(propertyName);
            // }
            continue;
        } else if (/^has[A-Z]/.test (propertyName)) {  // skip has methods
            continue;
        } else if (propertyName === '[object Object]') {
            // TODO: What property is '[object Object]'?
            continue;
        }
        let defaultValue = propertyValue ? JSON.stringify(propertyValue) : undefined;
        let propType = regexMatches[propertyName]?.type;
        if (propertyValue) {
            if (!propType) {
                propType = typeof propertyValue;
            }
        } else {
            if (!propType) {
                propType = "any";
            }
        }

        properties[propertyName] = {
            defaultValue: defaultValue,
            name: propertyName,
            type: propType,
            hasGetter: !setterOnlyProperties.has (propertyName),
            hasSetter: !getterOnlyProperties.has (propertyName),
        };
    }
    return Object.values(properties);
}

/*
    Gets the methods that will be created in Swift and Android
*/
function getMethodNames(): string[] {
    const exchange = new ccxt.Exchange();
    return [
        ...Object.keys(exchange.has),
        'describe',
        'loadMarkets',
        'setSandboxMode',
    ];
}

function getTypescriptHeaders(): MethodHeader[] {
    // Initialize empty array for results
    const results: MethodHeader[] = [];
    
    // Get the allowed method names
    const allowedMethods = new Set (getMethodNames ());
    
    // Read the typescript file content
    const src = fs.readFileSync (ccxtPaths['exchange'], "utf8");
    
    // Match method declarations
    const methodRegex = /^\s*(async\s+)?(\w+)\s*\(([^)]*)\)\s*(?::\s*Promise\s*<\s*([\s\S]*?)\s*>)?\s*\{/gm;
    
    let match;
    while ((match = methodRegex.exec (src)) !== null) {
        const isAsync = !!match[1];
        const methodName = match[2];
        // console.log(methodName);

        // Skip if method is not in allowedMethods
        if (!allowedMethods.has (methodName)) {
            continue;
        }

        const params = match[3].trim ();
        const returnType = match[4]?.trim () ?? "void";

        // Initialize parameter dictionary for this method
        const paramDict: {[ key: string ]: [ string, string | null ]} = {};

        // Split parameters and process each one
        if (params) {
            const paramList = params.split (/,(?![^{]*})(?![^\[]*\])/).map (p => p.trim ());

            for (const param of paramList) {
                // Match: name?: type = defaultValue
                const paramMatch = param.match (/^(\w+)(\?)?(?::\s*([^=]+))?\s*(?:=\s*(.+))?$/);
                if (paramMatch) {
                    const [ , name, optional, type = 'any', defaultValue ] = paramMatch;
                    const finalType = (type.trim () + (optional ? '?' : '')).replace (/\s+/g, '');
                    paramDict[name] = [ finalType, defaultValue?.trim() || null ];
                }
            }
        }

        results.push ({ methodName, paramDict, returnType, isAsync });
    }
    // console.log(JSON.stringify(results, null, 2));
    return results;
}

/**
 * Ensures the directory exists and writes/appends content to a file.
 * @param {string} filePath The path to the file.
 * @param {Array<string>} content The content of the file, line by line
 * @param {string | null} originalFilePath The path to the original file, if any.
 * @param {boolean} prepend Puts content at top of file if true
 * @param {boolean} noGeneratedHeader whether or not to prepend the 'this file is generated' header
 */
export function createGeneratedFile(
    filePath: string,
    content: string[],
    originalFilePath: string | null = null,
    replacements: {[key: string]: string} = {},
    noGeneratedHeader = false
) {

    const dirPath = path.dirname(filePath);
    if (!fs.existsSync(dirPath)) {  // Create the directory if it doesn't exist
        fs.mkdirSync(dirPath, { recursive: true });
    }
    const beginning = noGeneratedHeader ? '' : generatedHeader;
    fs.writeFileSync(filePath, beginning, 'utf8');

    if (originalFilePath) {
        let originalFileContent = fs.readFileSync(originalFilePath, 'utf8');
        for (const [key, value] of Object.entries(replacements)) {
            originalFileContent = originalFileContent.replace(new RegExp(key, 'g'), value);
        }
        fs.appendFileSync(filePath, originalFileContent, 'utf8');
    }
    let insert = '';
    if (content.length > 0) {
        insert = '\n' + content.join("\n") + '\n';
        for (const [key, value] of Object.entries(replacements)) {
            insert = insert.replace(new RegExp(key, 'g'), value);
        }
    }
    fs.appendFileSync(filePath, insert, 'utf8');
}

export const skippedProperties = new Set<string>([
    '[object Object]',

    // just didn't seem useful
    'proxiesModulesLoading',
    'marketsLoading',
    'reloadingMarkets',

    // TODO: change to getter only
    'headers',

    // TODO: couldn't figure out why the type was wrong
    'paddingMode',
    'precisionMode',
    'minFundingAddressLength',
    'lastRestRequestTimestamp',

    // not defined in go
    'accounts_by_id',
    'agent',
    'agent',
    'api_key',
    'base_currencies',
    'certified',
    'certified',
    'common_currencies',
    'countries',
    'countries',
    'decimal_places',
    'DECIMAL_PLACES',
    'dex',
    'enable_last_http_response',
    'enable_last_json_response',
    'enable_last_response_headers',
    'enable_rate_limit',
    'enableLastHttpResponse',
    'enableLastJsonResponse',
    'enableLastResponseHeaders',
    'fetch_implementation',
    'fetchImplementation',
    'funding_rates',
    'handle_content_type_application_zip',
    'handleContentTypeApplicationZip',
    'handleContentTypeApplicationZip',
    'http_agent',
    'http_exceptions',
    'http_proxy_agent_module',
    'https_proxy_agent_module',
    'httpAgent',
    'httpAgent',
    'https_agent',
    'httpsAgent',
    'httpsAgent',
    'is_browser',
    'is_deno',
    'is_electron',
    'is_node',
    'is_sandbox_mode_enabled',
    'is_web_worker',
    'is_windows',
    'isBrowser',
    'isDeno',
    'isElectron',
    'isNode',
    'isWebWorker',
    'isWindows',
    'last_json_response',
    'last_request_path',
    'last_response_headers',
    'last_rest_request_timestamp',
    'markets_by_altname',
    'markets_loading',
    'marketsByAltname',
    'max_value',
    'min_funding_address_length',
    'my_liquidations',
    'my_trades',
    'new_updates',
    'no_padding',
    'NO_PADDING',
    'node_http_module_loaded',
    'nodeHttpModuleLoaded',
    'nodeHttpModuleLoaded',
    'origin',
    'origin',
    'pad_with_zero',
    'PAD_WITH_ZERO',
    'padding_mode',
    'precision_constants',
    'precision_mode',
    'precisionConstants',
    'private_key',
    'pro',
    'pro',
    'proxies_modules_loading',
    'proxy_dictionaries',
    'quote_currencies',
    'quote_json_numbers',
    'quoteJsonNumbers',
    'quoteJsonNumbers',
    'rate_limit',
    'reduce_fees',
    'reloading_markets',
    'requires_eddsa',
    'requires_web_3',
    'requiresEddsa',
    'requiresWeb3',
    'return_response_headers',
    'round_down',
    'ROUND_DOWN',
    'round_up',
    'ROUND_UP',
    'round',
    'ROUND',
    'significant_digits',
    'SIGNIFICANT_DIGITS',
    'socks_proxy_agent_module_checked',
    'socks_proxy_agent_module',
    'stable_pairs',
    'stablePairs',
    'status',
    'streaming',
    'substitute_common_currency_codes',
    'target_account',
    'targetAccount',
    'tick_size',
    'TICK_SIZE',
    'token_bucket',
    'trigger_orders',
    'truncate',
    'TRUNCATE',
    'user_agent',
    'user_agent',
    'user_agents',
    'validate_client_ssl',
    'validate_server_ssl',
    'validateClientSsl',
    'validateServerSsl',
    'validateServerSsl',
    'wallet_address',
]);

/**
 * @param {function} methodTranspiler receives a string for a typescript method and creates a wrapper in another language
 * @param {string} originalFile file path for static non-transpiled content of the wrapper file
 * @param {string} newFile file path for the new wrapper file
 */
export function createWrapperFile (
    methodTranspiler: MethodTranspiler,
    propertyTranspiler: PropertyTranspiler,
    originalFile: string,
    newFile: string,
    replacements: StringDict = {},
    ws = false,
) {

    const headers = getTypescriptHeaders ();
    const properties: Property[] = getExchangeProperties (new ccxt.Exchange(), ccxtPaths['exchange'], 'Exchange');
    const content: string[] = [];
    const skippedMethods = new Set<string> ([
        'fetchCurrenciesWs',
        'fetchMarketsWs',
        'watchOHLCVForSymbols',
        'unWatchOHLCVForSymbols',
        'unWatchTicker',
        "fetchDepositWithdrawFees",

        // TODO: don't know how to make types encodable with params as type any
        'createOrders',
        'editOrders',
        'deleteOrders',
    ]);
    const wsProps = new Set<string> ([

    ]);

    for (const prop of properties) {
        if (
            skippedProperties.has (prop.name) || 
            (!ws && wsProps.has (prop.name))
        ) {
            continue;
        } else {
            content.push (propertyTranspiler (prop));
        }
    }

    for (const { methodName, paramDict, returnType, isAsync } of headers) {
        if (skippedMethods.has (methodName) || 
        (!ws && (
            methodName.startsWith ('watch') ||
            methodName.startsWith ('unWatch') ||
            methodName.includes ('Ws')
        ))) {
            continue;
        } else {
            content.push (
                methodTranspiler (methodName, paramDict, returnType, isAsync)
            );
        }
    }

    // Exchange.swift, ccxtwrapper.go, Exchange.java(soon)
    createGeneratedFile (newFile, content, originalFile, replacements);
}


export async function getLatestVersion (swift: boolean, pro: boolean) {
    let repo = swift ? "swift" : "android";
    if (pro) {
        repo += "-pro";
    }
    const url = `https://api.github.com/repos/ccxt-native/${repo}/releases/latest`;

    const response = await fetch(url, {
        headers: { "Accept": "application/vnd.github.v3+json" },
    });

    if (!response.ok) {
        throw new Error(`GitHub API error: ${response.status}`);
    }

    const data = await response.json();
    return data.tag_name;
}

export async function bumpVersion (swift: boolean, pro: boolean) {
    const version = await getLatestVersion (swift, pro);
    const [ major, minor, patch ] = version.replace (/^v/, "").split (".").map (Number);
    if (patch == 99) {
        return `v${major}.${minor + 1}.${patch}`;
    } else {
        return `v${major}.${minor}.${patch + 1}`;
    }    
}

export const customTypes = [  // Only those types that appear in swift headers
    'OrderRequest[]',
    'OrderRequest',
];

export const simpleTypes = new Set ([
    'boolean',
    'string',
    'number',
    'Int',
    'Num',
    'Str',
    'Bool',

    // go types
    'int',
    'int64',
    'bool',

    // swift types
    'String?',
    'Int?',
    'Double?',
    'Bool?',
]);

const exchangesJson = JSON.parse (fs.readFileSync (`${ccxtDir}/exchanges.json`, "utf8"));
export const allExchanges = exchangesJson.ids;
export const wsExchanges = exchangesJson.ws;

// const exchange = new ccxt.Exchange ();
// console.log (JSON.stringify (getExchangeProperties (exchange, ccxtPaths['exchange'], 'Exchange'), null, 2));
